<center>
	<h1 style="margin-bottom:0;">my first CPU designs</h1><h3 style="margin-top:0;">learning the ropes of making a good CPU</h3>
</center>
<p>
	I have always liked technology, always wanting to know how something works.<br>
	Eventually, i wanted to know how computers work.<br>
	Many videos were watched, but by far the best series is the one <a href="https://www.youtube.com/channel/UCS0N5baNlQWJCUrhCEo8WlA">Ben Eater</a> made.<br>
	He goes into grave detail as for how everything works, and if you want to learn, i highly suggest him.<br><br>
	I will not go into as much detail as Ben Eater does, instead giving a general overview of my projects.<br><br>
</p>
<h2>motivation</h2>
<p>
	My motivation of wanting to do this is a bit of a challenge to myself.<br>
	I've challenged myself to try to make a CPU to rival commercially available microcontrollers on power.<br>
	Think, atmega328P, atmega168 (used in the arduino).<br>
</p>
<h2>designing</h2>
<p>
	This goes over the design of my first CPU, i don't blame anyone for not understanding it fully.<br><br>
	The CPU that ben eater made is a RISC CPU.<br>
	This means that arguments and the instruction do not change the underlying behavior of the control unit.<br>
	My first design was quite simple, but not technically RISC.<br>
	It has three registers: A, B and C.<br>
	A and B are the inputs for the ALU and C is the output.<br>
	It also has a serial interface connected directly to the CPU.<br>
	It even takes only one cycle to complete or load an instruction!<br><br>
	Altough this sounds like a great CPU, that's not at all true.<br>
	Because it is a CISC CPU, making this in hardware is more complicated.<br>
	Because any instruction takes exactly one cycle, complex operations are impossible.<br>
	Because of the structure of the registers, more instructions than usual are required for the same operations.<br>
	Because of how instructions are 16 bits (8 bits instruction, 8 bits arguments), instruction flexibility is limited.<br>
	This is also an 8 bit CPU, which means that half of the theoretic memory is unussable for data.<br><br>
	But is this a bad thing? No.<br>
	I think it is good i made this CPU as it is.<br>
	You have to start somewhere, and for me that meant doing that is almost the simplest CPU you can make.<br>
	Most of what this is is a learning opertunity for me.<br>
</p>
<h2>after finishing the design</h2>
<p>
	I was very happy after i finished the design, not realising how much i had to learn.<br>
	The only program it ever significantly ran was fibonachi.<br>
	The fibonachi program is symbolic, because if you can do that, you can also do anything computable, given enough time and memory.<br>
	I showed that design to virtually anyone i knew at the time.<br>
	I started almost immediately trying to improve my designing skills.
</p>
<h2>conclusion</h2>
<p>
	The final design that this endeavor got me, is this one:<br>
	<img title="Click to enlarge." class="fit-inline may-big" style="width: 50%; height: 50%;" src="/data/projects/images/cpu_design0.png"><br>
	To the left you see the control unit, a big black box.<br>
	It is ironically the most complex part of this simple CPU.<br>
	Below, you see the ROM, which is loaded when the CPU is started.<br>
	To the right, you see the registers and how they are connected to the ALU.<br>
	In the end, it was a learning process more than a good CPU.
</p>
